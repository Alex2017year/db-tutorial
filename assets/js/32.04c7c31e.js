(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{485:function(e,v,_){"use strict";_.r(v);var i=_(14),s=Object(i.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"redis-面试总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-面试总结"}},[e._v("#")]),e._v(" Redis 面试总结")]),e._v(" "),_("h2",{attrs:{id:"redis-数据类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-数据类型"}},[e._v("#")]),e._v(" Redis 数据类型")]),e._v(" "),_("p",[e._v("问题：")]),e._v(" "),_("ul",[_("li",[e._v("Redis 数据类型有哪些？")]),e._v(" "),_("li",[e._v("Redis 各种数据类型适用于什么样的场景？")])]),e._v(" "),_("hr"),e._v(" "),_("p",[e._v("解答：")]),e._v(" "),_("p",[e._v("Redis 基本数据类型：")]),e._v(" "),_("table",[_("thead",[_("tr",[_("th",[e._v("数据类型")]),e._v(" "),_("th",[e._v("可以存储的值")]),e._v(" "),_("th",[e._v("操作")])])]),e._v(" "),_("tbody",[_("tr",[_("td",[e._v("STRING")]),e._v(" "),_("td",[e._v("字符串、整数或者浮点数")]),e._v(" "),_("td",[e._v("对整个字符串或者字符串的其中一部分执行操作"),_("br"),e._v(" 对整数和浮点数执行自增或者自减操作")])]),e._v(" "),_("tr",[_("td",[e._v("LIST")]),e._v(" "),_("td",[e._v("列表")]),e._v(" "),_("td",[e._v("从两端压入或者弹出元素"),_("br"),e._v(" 读取单个或者多个元素"),_("br"),e._v(" 进行修剪，只保留一个范围内的元素")])]),e._v(" "),_("tr",[_("td",[e._v("SET")]),e._v(" "),_("td",[e._v("无序集合")]),e._v(" "),_("td",[e._v("添加、获取、移除单个元素"),_("br"),e._v(" 检查一个元素是否存在于集合中"),_("br"),e._v(" 计算交集、并集、差集"),_("br"),e._v(" 从集合里面随机获取元素")])]),e._v(" "),_("tr",[_("td",[e._v("HASH")]),e._v(" "),_("td",[e._v("包含键值对的无序散列表")]),e._v(" "),_("td",[e._v("添加、获取、移除单个键值对"),_("br"),e._v(" 获取所有键值对"),_("br"),e._v(" 检查某个键是否存在")])]),e._v(" "),_("tr",[_("td",[e._v("ZSET")]),e._v(" "),_("td",[e._v("有序集合")]),e._v(" "),_("td",[e._v("添加、获取、删除元素"),_("br"),e._v(" 根据分值范围或者成员来获取元素"),_("br"),e._v(" 计算一个键的排名")])])])]),e._v(" "),_("p",[e._v("Redis 各种数据类型的应用比较繁杂，详情可以参考："),_("a",{attrs:{href:"https://github.com/dunwu/db-tutorial/blob/master/docs/nosql/redis/redis-datatype.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("Redis 数据类型"),_("OutboundLink")],1)]),e._v(" "),_("h2",{attrs:{id:"redis-内存淘汰"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-内存淘汰"}},[e._v("#")]),e._v(" Redis 内存淘汰")]),e._v(" "),_("p",[e._v("问题：")]),e._v(" "),_("ul",[_("li",[e._v("Redis 有哪些淘汰策略？")]),e._v(" "),_("li",[e._v("这些淘汰策略分别适用于什么场景？")]),e._v(" "),_("li",[e._v("Redis 有哪些删除失效 key 的方法？")]),e._v(" "),_("li",[e._v("如何设置 Redis 中键的过期时间？")]),e._v(" "),_("li",[e._v("如果让你实现一个 LRU 算法，怎么做？")])]),e._v(" "),_("hr"),e._v(" "),_("p",[e._v("解答：")]),e._v(" "),_("p",[e._v("Redis 内存淘汰策略：")]),e._v(" "),_("ul",[_("li",[_("strong",[_("code",[e._v("noeviction")])]),e._v(" - 当内存使用达到阈值的时候，所有引起申请内存的命令会报错。这是 Redis 默认的策略。")]),e._v(" "),_("li",[_("strong",[_("code",[e._v("allkeys-lru")])]),e._v(" - 在主键空间中，优先移除最近未使用的 key。")]),e._v(" "),_("li",[_("strong",[_("code",[e._v("allkeys-random")])]),e._v(" - 在主键空间中，随机移除某个 key。")]),e._v(" "),_("li",[_("strong",[_("code",[e._v("volatile-lru")])]),e._v(" - 在设置了过期时间的键空间中，优先移除最近未使用的 key。")]),e._v(" "),_("li",[_("strong",[_("code",[e._v("volatile-random")])]),e._v(" - 在设置了过期时间的键空间中，随机移除某个 key。")]),e._v(" "),_("li",[_("strong",[_("code",[e._v("volatile-ttl")])]),e._v(" - 在设置了过期时间的键空间中，具有更早过期时间的 key 优先移除。")])]),e._v(" "),_("p",[e._v("如何选择内存淘汰策略：")]),e._v(" "),_("ul",[_("li",[e._v("如果数据呈现幂等分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用 "),_("code",[e._v("allkeys-lru")]),e._v("。")]),e._v(" "),_("li",[e._v("如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用 "),_("code",[e._v("allkeys-random")]),e._v("。")]),e._v(" "),_("li",[_("code",[e._v("volatile-lru")]),e._v(" 策略和 "),_("code",[e._v("volatile-random")]),e._v(" 策略适合我们将一个 Redis 实例既应用于缓存和又应用于持久化存储的时候，然而我们也可以通过使用两个 Redis 实例来达到相同的效果。")]),e._v(" "),_("li",[e._v("将 key 设置过期时间实际上会消耗更多的内存，因此我们建议使用 "),_("code",[e._v("allkeys-lru")]),e._v(" 策略从而更有效率的使用内存。")])]),e._v(" "),_("p",[e._v("Redis 删除失效主键的方法主要有两种：")]),e._v(" "),_("ul",[_("li",[e._v("消极方法（passive way），在主键被访问时如果发现它已经失效，那么就删除它。")]),e._v(" "),_("li",[e._v("主动方法（active way），周期性地从设置了失效时间的主键中选择一部分失效的主键删除。")])]),e._v(" "),_("p",[e._v("LRU 算法实现思路：")]),e._v(" "),_("p",[_("code",[e._v("HashMap")]),e._v(" + "),_("code",[e._v("LinkedList")])]),e._v(" "),_("h2",{attrs:{id:"redis-持久化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-持久化"}},[e._v("#")]),e._v(" Redis 持久化")]),e._v(" "),_("p",[e._v("问题：")]),e._v(" "),_("ul",[_("li",[e._v("Redis 有哪些持久化方式？")]),e._v(" "),_("li",[e._v("Redis 的不同持久化方式的特性和原理是什么？")]),e._v(" "),_("li",[e._v("RDB 和 AOF 各有什么优缺点？分别适用于什么样的场景？")]),e._v(" "),_("li",[e._v("Redis 执行持久化时，可以处理请求吗？")]),e._v(" "),_("li",[e._v("AOF 有几种同步频率？")])]),e._v(" "),_("hr"),e._v(" "),_("p",[e._v("解答：")]),e._v(" "),_("p",[e._v("Redis 支持两种持久化方式：RDB 和 AOF。")]),e._v(" "),_("p",[e._v("RDB 即快照方式，它将某个时间点的所有 Redis 数据保存到一个经过压缩的二进制文件（RDB 文件）中。")]),e._v(" "),_("p",[e._v("AOF(Append Only File) 是以文本日志形式将所有写命令追加到 AOF 文件的末尾，以此来记录数据的变化。")]),e._v(" "),_("p",[e._v("更详细的特性及原理说明请参考："),_("a",{attrs:{href:"https://github.com/dunwu/db-tutorial/blob/master/docs/nosql/redis/redis-persistence.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("Redis 持久化"),_("OutboundLink")],1)]),e._v(" "),_("h2",{attrs:{id:"redis-高并发"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-高并发"}},[e._v("#")]),e._v(" Redis 高并发")]),e._v(" "),_("p",[e._v("问题：")]),e._v(" "),_("ul",[_("li",[e._v("Redis 是单线程模型，为何吞吐量还很高？")]),e._v(" "),_("li",[e._v("Redis 集群如何分片和寻址？")]),e._v(" "),_("li",[e._v("Redis 集群如何扩展？")]),e._v(" "),_("li",[e._v("Redis 集群如何保证数据一致？")]),e._v(" "),_("li",[e._v("Redis 集群如何规划？你们公司的生产环境上如何部署 Redis 集群？")]),e._v(" "),_("li",[e._v("Redis 的并发竞争问题如何解决?")])]),e._v(" "),_("hr"),e._v(" "),_("p",[e._v("解答：")]),e._v(" "),_("p",[e._v("Redis 为单进程单线程模式，采用队列模式将并发访问变为串行访问。")]),e._v(" "),_("p",[e._v("Redis 单机吞吐量也很高，能达到几万 QPS，但需要格外注意的是："),_("strong",[e._v("Redis 是单线程模型")]),e._v("。很多人可能会奇怪，Redis 是单线程模型，如何能处理高并发请求呢？")]),e._v(" "),_("p",[e._v("原因在于：")]),e._v(" "),_("ul",[_("li",[e._v("Redis 读写都是内存操作。")]),e._v(" "),_("li",[e._v("Redis 基于"),_("strong",[e._v("非阻塞的 IO 多路复用机制")]),e._v("，同时监听多个 socket，将产生事件的 socket 压入内存队列中，事件分派器根据 socket 上的事件类型来选择对应的事件处理器进行处理。")]),e._v(" "),_("li",[e._v("单线程，避免了线程创建、销毁、上下文切换的开销，并且避免了资源竞争。")])]),e._v(" "),_("p",[e._v("Redis 的高并发通过主从架构来实现。Redis 集群采用主从模型，提供复制和故障转移功能，来保证 Redis 集群的高可用。通常情况，一主多从模式已经可以满足大部分项目的需要。根据实际的并发量，可以通过增加节点来扩展并发吞吐。")]),e._v(" "),_("p",[e._v("一主多从模式下，主节点负责写操作（单机几万 QPS），从节点负责查询操作（单机十万 QPS）。")]),e._v(" "),_("p",[e._v("进一步，如果需要缓存大量数据，就需要分区（sharding），Redis 集群通过划分虚拟 hash 槽来分片，进行数据分享。")]),e._v(" "),_("p",[e._v("根据 CAP 理论，Consistency、Availability、Partition tolerance 三者不可兼得，而 Redis 集群的选择是 AP。Redis 集群节点间采用异步通信方式，不保证强一致性，尽力达到最终一致性。")]),e._v(" "),_("p",[_("code",[e._v("Redis")]),e._v(" 集群一般由 "),_("strong",[e._v("多个节点")]),e._v(" 组成，节点数量至少为 "),_("code",[e._v("6")]),e._v(" 个，才能保证组成 "),_("strong",[e._v("完整高可用")]),e._v(" 的集群。")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/10/10/16db5250b0d1c392?w=1467&h=803&f=png&s=43428",alt:"img"}})]),e._v(" "),_("p",[e._v("更详细的特性及原理说明请参考："),_("a",{attrs:{href:"https://github.com/dunwu/db-tutorial/blob/master/docs/nosql/redis/redis-cluster.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("Redis 集群"),_("OutboundLink")],1)]),e._v(" "),_("h2",{attrs:{id:"redis-高可用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-高可用"}},[e._v("#")]),e._v(" Redis 高可用")]),e._v(" "),_("p",[e._v("问题：")]),e._v(" "),_("ul",[_("li",[e._v("Redis 如何实现高可用？")]),e._v(" "),_("li",[e._v("Redis 哨兵的功能？")]),e._v(" "),_("li",[e._v("Redis 哨兵的原理？")]),e._v(" "),_("li",[e._v("Redis 哨兵如何选举 Leader？")]),e._v(" "),_("li",[e._v("Redis 如何实现故障转移？")])]),e._v(" "),_("hr"),e._v(" "),_("p",[e._v("解答：")]),e._v(" "),_("p",[e._v("Redis 的高可用是通过哨兵来实现（Raft 协议的 Redis 实现）。Sentinel（哨兵）可以监听主服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。")]),e._v(" "),_("p",[e._v("由一个或多个 Sentinel 实例组成的 Sentinel 系统可以监视任意多个主服务器，以及这些主服务器的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。")]),e._v(" "),_("p",[_("img",{attrs:{src:"http://dunwu.test.upcdn.net/snap/20200131135847.png",alt:"img"}})]),e._v(" "),_("p",[e._v("更详细的特性及原理说明请参考："),_("a",{attrs:{href:"https://github.com/dunwu/db-tutorial/blob/master/docs/nosql/redis/redis-sentinel.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("Redis 哨兵"),_("OutboundLink")],1)]),e._v(" "),_("h2",{attrs:{id:"redis-复制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-复制"}},[e._v("#")]),e._v(" Redis 复制")]),e._v(" "),_("p",[e._v("问题：")]),e._v(" "),_("ul",[_("li",[e._v("Redis 复制的工作原理？Redis 旧版复制和新版复制有何不同？")]),e._v(" "),_("li",[e._v("Redis 主从节点间如何复制数据？")]),e._v(" "),_("li",[e._v("Redis 的数据一致性是强一致性吗？")])]),e._v(" "),_("hr"),e._v(" "),_("p",[e._v("解答：")]),e._v(" "),_("p",[e._v("旧版复制基于 "),_("code",[e._v("SYNC")]),e._v(" 命令实现。分为同步（sync）和命令传播（command propagate）两个操作。这种方式存在缺陷：不能高效处理断线重连后的复制情况。")]),e._v(" "),_("p",[e._v("新版复制基于 "),_("code",[e._v("PSYNC")]),e._v(" 命令实现。同步操作分为了两块：")]),e._v(" "),_("ul",[_("li",[_("strong",[_("code",[e._v("完整重同步（full resychronization）")])]),e._v(" 用于初次复制；")]),e._v(" "),_("li",[_("strong",[_("code",[e._v("部分重同步（partial resychronization）")])]),e._v(" 用于断线后重复制。\n"),_("ul",[_("li",[e._v("主从服务器的"),_("strong",[e._v("复制偏移量（replication offset）")])]),e._v(" "),_("li",[e._v("主服务器的"),_("strong",[e._v("复制积压缓冲区（replication backlog）")])]),e._v(" "),_("li",[_("strong",[e._v("服务器的运行 ID")])])])])]),e._v(" "),_("p",[e._v("Redis 集群主从节点复制的工作流程：")]),e._v(" "),_("ul",[_("li",[e._v("步骤 1. 设置主从服务器")]),e._v(" "),_("li",[e._v("步骤 2. 主从服务器建立 TCP 连接。")]),e._v(" "),_("li",[e._v("步骤 3. 发送 PING 检查通信状态。")]),e._v(" "),_("li",[e._v("步骤 4. 身份验证。")]),e._v(" "),_("li",[e._v("步骤 5. 发送端口信息。")]),e._v(" "),_("li",[e._v("步骤 6. 同步。")]),e._v(" "),_("li",[e._v("步骤 7. 命令传播。")])]),e._v(" "),_("p",[e._v("更详细的特性及原理说明请参考："),_("a",{attrs:{href:"https://github.com/dunwu/db-tutorial/blob/master/docs/nosql/redis/redis-replication.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("Redis 复制"),_("OutboundLink")],1)]),e._v(" "),_("h2",{attrs:{id:"redis-事务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-事务"}},[e._v("#")]),e._v(" Redis 事务")]),e._v(" "),_("p",[e._v("问题：")]),e._v(" "),_("ul",[_("li",[e._v("Redis 支持事务吗？")]),e._v(" "),_("li",[e._v("Redis 事务是严格意义的事务吗？Redis 为什么不支持回滚。")]),e._v(" "),_("li",[e._v("Redis 事务如何工作？")]),e._v(" "),_("li",[e._v("了解 Redis 事务中的 CAS 行为吗？")]),e._v(" "),_("li",[e._v("除了事务，还有其他批量执行 Redis 命令的方式吗？")])]),e._v(" "),_("p",[e._v("解答：")]),e._v(" "),_("p",[_("strong",[e._v("Redis 提供的不是严格的事务，Redis 只保证串行执行命令，并且能保证全部执行，但是执行命令失败时并不会回滚，而是会继续执行下去")]),e._v("。")]),e._v(" "),_("p",[e._v("Redis 不支持回滚的理由：")]),e._v(" "),_("ul",[_("li",[e._v("Redis 命令只会因为错误的语法而失败，或是命令用在了错误类型的键上面。")]),e._v(" "),_("li",[e._v("因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。")])]),e._v(" "),_("p",[_("code",[e._v("MULTI")]),e._v(" 、 "),_("code",[e._v("EXEC")]),e._v(" 、 "),_("code",[e._v("DISCARD")]),e._v(" 和 "),_("code",[e._v("WATCH")]),e._v(" 是 Redis 事务相关的命令。")]),e._v(" "),_("ul",[_("li",[_("strong",[_("a",{attrs:{href:"https://redis.io/commands/multi",target:"_blank",rel:"noopener noreferrer"}},[_("code",[e._v("MULTI")]),_("OutboundLink")],1),e._v(" 命令用于开启一个事务，它总是返回 OK 。")])]),e._v(" "),_("li",[_("strong",[_("a",{attrs:{href:"https://redis.io/commands/exec",target:"_blank",rel:"noopener noreferrer"}},[_("code",[e._v("EXEC")]),_("OutboundLink")],1),e._v(" 命令负责触发并执行事务中的所有命令。")])]),e._v(" "),_("li",[_("strong",[e._v("当执行 "),_("a",{attrs:{href:"https://redis.io/commands/discard",target:"_blank",rel:"noopener noreferrer"}},[_("code",[e._v("DISCARD")]),_("OutboundLink")],1),e._v(" 命令时， 事务会被放弃， 事务队列会被清空， 并且客户端会从事务状态中退出。")])]),e._v(" "),_("li",[e._v("**"),_("a",{attrs:{href:"https://redis.io/commands/watch",target:"_blank",rel:"noopener noreferrer"}},[_("code",[e._v("WATCH")]),_("OutboundLink")],1),e._v(" 命令可以为 Redis 事务提供 check-and-set （CAS）行为。**被 WATCH 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消， EXEC 返回 nil-reply 来表示事务已经失败。")])]),e._v(" "),_("p",[e._v("Redis 是一种基于 C/S 模型以及请求/响应协议的 TCP 服务。Redis 支持管道技术。管道技术允许请求以异步方式发送，即旧请求的应答还未返回的情况下，允许发送新请求。这种方式可以大大提高传输效率。使用管道发送命令时，Redis Server 会将部分请求放到缓存队列中（占用内存），执行完毕后一次性发送结果。如果需要发送大量的命令，会占用大量的内存，因此应该按照合理数量分批次的处理。")]),e._v(" "),_("h2",{attrs:{id:"redis-vs-memcached"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-vs-memcached"}},[e._v("#")]),e._v(" Redis vs. Memcached")]),e._v(" "),_("p",[e._v("Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。memcache 支持简单的数据类型，String。")]),e._v(" "),_("p",[e._v("Redis 支持数据的备份，即 master-slave 模式的数据备份。")]),e._v(" "),_("p",[e._v("Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memecache 把数据全部存在内存之中")]),e._v(" "),_("p",[e._v("redis 的速度比 memcached 快很多")]),e._v(" "),_("p",[e._v("Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的 IO 复用模型。")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/4/18/162d7773080d4570?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"Redis与Memcached的区别与比较"}})]),e._v(" "),_("p",[e._v("如果想要更详细了解的话，可以查看慕课网上的这篇手记（非常推荐） "),_("strong",[e._v("：《脚踏两只船的困惑 - Memcached 与 Redis》")]),e._v("："),_("a",{attrs:{href:"https://www.imooc.com/article/23549",target:"_blank",rel:"noopener noreferrer"}},[e._v("www.imooc.com/article/23549"),_("OutboundLink")],1)]),e._v(" "),_("h3",{attrs:{id:"redis-与-memcached-的选择"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-与-memcached-的选择"}},[e._v("#")]),e._v(" Redis 与 Memcached 的选择")]),e._v(" "),_("p",[_("strong",[e._v("终极策略：")]),e._v(" 使用 Redis 的 String 类型做的事，都可以用 Memcached 替换，以此换取更好的性能提升； 除此以外，优先考虑 Redis；")]),e._v(" "),_("h2",{attrs:{id:"参考资料"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[e._v("#")]),e._v(" 参考资料")]),e._v(" "),_("ul",[_("li",[_("a",{attrs:{href:"https://juejin.im/post/5ad6e4066fb9a028d82c4b66",target:"_blank",rel:"noopener noreferrer"}},[e._v("面试中关于 Redis 的问题看这篇就够了"),_("OutboundLink")],1)])])])}),[],!1,null,null,null);v.default=s.exports}}]);